#include <stdio.h>
#include <assert.h>

void test(int** ptr)
{}

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int brr[5][10] = { { 1,2,3,4,5,6,7,8,9,10 } ,{ 1,2,3,4,5,6,7,8,9,10 } ,{ 1,2,3,4,5,6,7,8,9,10 } ,{ 1,2,3,4,5,6,7,8,9,10 } ,{ 1,2,3,4,5,6,7,8,9,10 } };
	int* crr[10] = { NULL };

	int* ap = NULL;
	int(*aq)[10] = NULL;	//[10]可以理解为aq的步长为10个int
	int(*bp)[10] = NULL;	//[10]可以理解为bq的步长为10个int
	int(*cp)[1] = NULL;		//[1] 可以理解为bq的步长为1个int

	ap = arr;				//ap == arr == &arr[0],首元素arr[0]的类型是int					|*****|

	//aq = arr; 此句如果这样写，会出现：warning C4047 : “ = ” : “int(*)[10]”与“int * ”的间接级别不同
	aq = &arr;				//无warning，可见‘&’操作符不能简单理解为arr的地址，即不能简单理解为二级指针，此处是取arr的步进，‘&’有两个意思：取地址和取步进，‘*’同理

	//cp = arr; 此句如果这样写，会出现：warning C4047 : “ = ” : “int(*)[1]”与“int * ”的间接级别不同，逻辑上“int(*)[1]”与“int * ”相同，但形式上不同	|*****|

	printf("ap = \t%p\n", ap);
	printf("ap+1 = \t%p\n", ap + 1);//(ap + 1) == &ap[1] == &arr[1]

	printf("aq = \t%p\n", aq);		
	printf("aq = \t%p\n", aq[0]);
	printf("aq+1 = \t%p\n", aq + 1);
	printf("aq+1 = \t%p\n", aq[1]); //(aq + 1) == &aq[1],但是aq[1]指向的数组不存在，aq与ap的步进不同

	printf("\n");

	bp = brr;						//bp == brr == &brr[0],首元素brr[0]的类型是int[10]		 |*****|
	printf("bp = \t\t%p\n", bp);
	printf("bp[0] = \t%p\n", bp[0]);//(bp + 0) == &bp[0] == &brr[0]
	printf("bp+1 = \t\t%p\n", bp + 1);
	printf("bp[1] = \t%p\n", bp[1]);//(bp + 1) == &bp[1] == &brr[1]

	/*注意到 |*****| 行中，分析如下：*/

	int  p1 = 0;				//变量p1的类型是int，p1是基本变量
	int* p2 = NULL;				//变量p2的类型是int*，p2是指针变量；或者变量*p2的类型是int
	int**p3 = NULL;				//变量p3的类型是int**，p3是二级指针变量；或者变量*p3的类型是int*；或者变量**p3的类型是int
	int  p4[1] = {0};			//变量p4的类型是int[1],p4是数组变量,&p4的步长是1个int；或者变量p4[1]的类型是int，p4表示一维数组首元素地址
	int  p5[10] = {0};			//变量p5的类型是int[10],p5是数组变量,&p5的步长是10个int；或者变量p5[10]的类型是int，p5表示一维数组首元素地址
	int* p6[10] = { NULL };		//变量p6的类型是int*[10],p6是指针数组变量,&p6的步长是10个int*；或者变量p6[10]的类型是int*，p6表示一维数组首元素地址
	int**p7[10] = { NULL };		//变量p7的类型是int**[10],p7是指针数组变量,&p7的步长是10个int**；或者变量p7[10]的类型是int**；或者变量*p7[10]的类型是int*；或者变量**p7[10]的类型是int，p7表示一维数组首元素地址

	int (*p8)[10] = NULL;		//变量p8的类型是int(*)[10],p8是数组指针变量,&(*p8)的步长是10个int；或者变量(*p8)[10]的类型是int，(*p8)表示一维数组首元素地址
	p8 = &arr;					//正确
	p8 = &brr[0];				//正确，p8 = &brr[0]，&brr[0]+1 == &brr[1]

	assert( p8+1 == &brr[1] );	//正确，p8+1 ==  &brr[1]
	assert( *(p8 + 1) == brr[1] );
	assert( *(*(p8+1)+1) == brr[1][1] );

	int*(*p9)[10] = NULL;		//变量p9的类型是int*(*)[10],p9是数组指针变量,&(*p9)的步长是10个int*；或者变量(*p9)[10]的类型是int*；或者变量*(*p9)[10]的类型是int，(*p9)表示一维数组首元素地址

	int p10[5][10] = { 0 };		//变量p10的类型是int[5][10],p10是数组变量,p10步长是[5][10]个int；或者变量p10[5]的类型是int[10],步长是10个int；或者变量p[5][10]的类型是int
								//变量p10[5]的类型是int[10],&p10[5]步长是10个int,即变量p10[0-4]的类型是int[10],&p10[0-4]步长是10个int，相当于每一行数组的地址
	p8 = &p10[0];				//&p10[0]表示首元素取步长
	assert( p8 == p10 );		//p10表示首元素地址,上句等价于p8 = p10;

	printf("%d\n",(int)sizeof(p8));
	printf("%d\n", (int)sizeof(&p10[0]));
	printf("%d\n", (int)sizeof(p10[0]));
	printf("%d\n", (int)sizeof(p10));
	printf("%d\n", (int)sizeof(&p10));

	test(crr);
	test(&crr[0]);
	//test(&crr);  err
	/*
	总结如下：

	1、变量的定义，即是定义变量的性质，分别为性和质。
	2、质：根据运算符与变量名的结合优先顺序，由内向外掏心。
	3、性：根据运算符与变量名的结合优先逆序，由外向内剥皮。
	4、变量的类型：变量定义表达式中，除去变量名的剩余部分。
	5、分析方法：按照表达式，形式上分析，编译器的分析方法。
	6、‘&’有两个意思：取地址和取步进；同理，‘*’表示解步进和解地址。
	7、关于数组：数组名通常表示首元素地址，即：&(首元素)。
	*/

	return 0;
}
